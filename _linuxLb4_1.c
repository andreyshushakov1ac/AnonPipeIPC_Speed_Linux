/* 

Измерение скорость передачи данных между процессом-предком (отправитель) и процессом-потомком (получатель)
разных объёмов данных (от 2 до 20 Мбайт) через неименованный канал. 
Передаваемые данные: случайные числа от 0 до 255.

Измерение скорости происходит путём фиксации текущего времени (с 01.01.1970) в процессе-предке (сек[10] + наносек[9])
и сохранении этого времени в первые 19 элементов буфера для записи в канал.
Далее процесс-предок вычитывает данные из канала в свой буфер, после чего фиксирует текущее время. 
Далее находит разность времени и отображает её в терминале.

*ПРИМЕЧАНИЕ 
Функция write(...) блокирует исполнение текущего потока до тех пор, пока данные пока канал не освободиться,
т.е. пока данные оттуда не будут удалены (переменщены в свой буфер) функцией read(...).
Аналогично с read(...): из пустого канала не читает, но блокирует поток.

 */

#include <sys/wait.h>
#include <stdio.h> // содержит функции ввода-вывода, такие как printf и scanf.
#include <stdlib.h> //содержит функции для работы с памятью, такие как malloc и free, а также функции для преобразования типов данных, такие как atoi и atof.
#include <unistd.h> //содержит функции для работы с системными вызовами, такие как fork и exec.
#include <time.h> // содержит функции для работы с временем, такие как time и localtime

#define OneMbyte 1048576 // 1 МБ (1048576 байт) - начальный размер сообщения

// Получает на вход по 2 значения: секунды и наносекунды (от 01.01.1970). Возвращает разность
float time_diff(int isek1, int iusek1, int isek2, int iusek2);

// Преобразование массива char в число (конкатенация всех символов-цифр). n - размер массива char
int charPointToInt (char* buf, int n);

// Выводит текущее время через два массива типа char: первый- секунды (10 символов) с 01.01.1970, второй- микросекунды (6 символов)
void get_time(char* sec, char* usec) ;

/* 
Создаёт буфер размером size байт (память выделяется динамически) и заполняет его 
числами от 0 до 255. Возвращает указатель на этот буфер
ВАЖНО (!) потом освободить буфер: "free (char* buffer);" 
*/
char* generate_buffer(int size); 


//================================================================================
int main (){	
	
int fd[2];  // 2 дескриптора для канала
int pid; // для PID , PPID
char* buf; // указатель на буфер для чтения из канала 

// Создание неименованного канала + проверка на ошибку
if (pipe(fd) == -1)
{
	perror("pipe failed"); 
	exit(1);
}
// Создание процесса-потомка + проверка на ошибку
if ((pid = fork()) < 0)
{
	perror("fork failed"); 
	exit(2);
}

////////////////////////////////////
//////////////////////////////////////////////////////
////////////////////////////////////

// ЕСЛИ СЕЙЧАС ВЫПОЛНЯЕТСЯ ПРОЦЕСС-ПРЕДОК
else if (pid > 0) 
{ 
	close(fd[0]); // закрываем дескриптор чтения из канала, т.к. процесс-предок только записывает
	
	int i = 2;  // Кол-во Мбайт
	int j=0;   // индекс для вспм цикла
	int wr; // для возвращаемого значения write()
	char sek[10], usek[9]; // для времени сек, наносек 
	
	// В цикле передадим 10 сообщений разного объёма, ожидая прочтения потомком после каждого
	while (i <= 20)
	{
		

		
		// Создаём и заполняем буфер случайными элементами
		buf = generate_buffer(i*OneMbyte);
		
				// Сохраняем текущее время
		get_time(sek,usek);
		
		///usleep (200*100*1000); 
		
		// Записываем в первые 19 элментов буфера для отправки текущее значение секунд и наносекунд (10+9)
		for (j=0;j<19;j++)
		{
			if (j<10)
				buf[j] = sek[j];
			else if (j>=10)
				buf[j] = usek[j-10];
		}  
		
		///printf ("\nВ ПРЕДКЕ ДО ЗАПИСИ: sek = %s  usek = %s\n", sek,usek);
		///printf("===ПРЕДОК ГОТОВ К ЗАПИСИ===");//,sek,usek);
		///usleep (100*100*1000);
		
		// Запись в канал
		 wr = write(fd[1],  buf/* generate_buffer(i*OneMbyte ) */ , i*OneMbyte ); // записывает данные указанного размера из буфера buf в файл с ф.дескр-м fd[1] 
		if (wr == -1) // проверка на ошибку
		{
			perror("write");
			exit(EXIT_FAILURE);
		}
		///usleep (10*100*1000); 
		///else  
			///printf("\n===ЗАПИСЬ ПРОШЛА УСПЕШНО====\n");
		
		i = i + 2;
		
		///usleep (200*100*1000);  // ждём 100мс перед отправкой новой посылки, чтоб старая наверняка была получена за это время
		free (buf);
	}
	close(fd[1]); // закрываем дескриптор записи в канал: чзапись завершена	
	wait(NULL);
}

////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////

// ЕСЛИ СЕЙЧАС ВЫПОЛНЯЕТСЯ ПРОЦЕСС-ПОТОМОК
else if (pid == 0) 
{ 
		///usleep(30*100*1000);
	
	close(fd[1]); // закрываем дескриптор записи в канал, т.к. процесс-потомок только читает 	
	
	int wasRead[10]; // кол-во прочитанных байт в каждом из 10 сообщений
	int i = 2; // кол-во Мбайт в сообщении
	float itog_time; // искомое время передачи
	int isek2, iusek2; // время прочтения
	int isek1, iusek1; // время отправки
	int j=0; 
	char usekBuf[9]; //вспм для времени отправки
	
char* buf; // указатель на буфер для чтения из канала 
char sek[10], usek[9]; // для времени сек, наносек 
	
	
	// Входим в цикл чтения сообщений, каждое на 2 Мбайта больше предыдущего
	while (i <= 20)
	{
		
		///usleep (120*100*1000);
		
		if ( ( buf = (char*)malloc(i*OneMbyte* sizeof(char)) ) == NULL )
			{printf("exit(7);"); exit(4);}
		
		
		wasRead[i/2] = read(fd[0], buf, i*OneMbyte);
		if (wasRead[i/2] == -1) 
		{
			perror("read");
			exit(EXIT_FAILURE);
		}
		
		///else if (wasRead[i/2] > 0) // что-то прочтено
		///{
			
			// Манипуляции временем для получения итогового времени (time) отправки-получения 
	
			///usleep (10*100*1000);
			
			// Время получения сообщения
			get_time(sek,usek);  	
			
			// Выделение отделбьного массива наносекунд из буфера 
			for (j=10;j<19;j++)
				usekBuf[j-10] = buf[j];	
			
			//Конкатенация char в int
				// время получения
			isek2 = charPointToInt(sek,10);		
			iusek2 = charPointToInt(usek,9); 	
			
				// время отправки
			isek1 = charPointToInt(buf,10);	 // время в сек 
			iusek1 = charPointToInt(usekBuf,9); // время в наносек
				
			///printf ("В ПОТОМКЕ ДО ЗАПИСИ: isek1 = %d  iusek1 = %d\n", isek1,iusek1);
			///printf("ПРОЧИТАНО В: строки-> sek = %s  usek = %s  int->  isek = %d  iusek = %d \n",sek,usek,isek2,iusek2); 			

			itog_time = time_diff(isek1, iusek1, isek2, iusek2) ;
			
			printf("Сообщение № %d:		%.9f сек (%d Мбайт)\n", i/2, itog_time, (OneMbyte*i)/(1024*1024));			
			
			i = i + 2;
			
			///usleep (120*100*1000);
			
			free(buf);
			///printf("Сообщение № %d\nОтправлено предком в канал: %d байт (%d Мбайт)  Получено потомком из канала: %d байт (%d Мбайт)\nВремени прошло: %.9f сек\n\n", i/2, (OneMbyte*i), (OneMbyte*i)/(1024*1024) , wasRead[i/2], wasRead[i/2]/(1024*1024), itog_time); 
			///printf("\n===ВРЕМЯ ПРИ ПОЛУЧЕНИИ====\nisek1 = %d		iusek1 = %d\niusek2 = %d		iusek2 = %d\n========\n\n",isek1, iusek1, isek2, iusek2);
		///}
		 
		
	}
	close(fd[0]); // закрываем дескриптор чтения из канала: чтение закончили
		
}	
}//end
//================================================================================

/* 
Создаёт буфер размером size байт (память выделяется динамически) и заполняет его 
числами от 0 до 255. Возвращает указатель на этот буфер
ВАЖНО (!) потом освободить буфер: "free (char* buffer);" 
*/
char* generate_buffer(int size) 
{
	char* buffer;
     if ( ( buffer = (char*)malloc(size * sizeof(char)) ) == NULL )
		{printf("exit(4);"); exit(4);}
	else
	{
		
		int i;
		for (i = 19; i < size; i++) // c 19ого, т.к. элементы 0-18 будут заполнены временем
			buffer[i] = rand() % 256;	
		
	}
	//////
	/* char sek[10], usek[9]; // для времени сек,микросек
	//Сохраняем текущее время в секундах в 0-9 элементах буфера и в микросекундах в 10-15 элементах
	get_time(sek,usek);	 int j;
		for (j=0;j<19;j++)
		{
			if (j<10)
				buffer[j] = sek[j];
			else if (j>=10)
				buffer[j] = usek[j-10]; 
		} 
	printf ("\nВ ПРЕДКЕ ДО ЗАПИСИ: sek = %s  usek = %s\n", sek,usek);*/
	
    return buffer;
}

// Выводит текущее время через два массива типа char: первый- секунды с 01.01.1970, второй- наносекунды
void get_time(char* sec, char* usec) 
{
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    sprintf(sec, "%ld", ts.tv_sec);
    sprintf(usec, "%ld", ts.tv_nsec);
}

// Преобразование массива char в число (конкатенация всех символов-цифр). n - размер массива char
int charPointToInt (char* buf, int n)
{
    int result = 0;
    for (int i = 0; i < n; i++) {
        result = result * 10 + (buf[i] - '0');
    }
    return result;
}

// Получает на вход по 2 значения: секунды и наносекунды (от 01.01.1970). Возвращает разность
float time_diff(int isek1, int iusek1, int isek2, int iusek2) 
{
    long long usec1 = isek1 * 1000000000LL + iusek1;
    long long usec2 = isek2 * 1000000000LL + iusek2;
    return (usec2 - usec1) / 1000000000.0f;
}
/* long long (LL). LL используется для указания, что число должно быть представлено в 64-битном формате, 
что позволяет сохранить значения, превышающие максимальное значение int (2147483647).  */



